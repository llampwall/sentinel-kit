{
	"meta": {
		"generatedAt": "2025-11-11T13:41:54.518Z",
		"tasksAnalyzed": 10,
		"totalTasks": 10,
		"analysisCount": 10,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": false
	},
	"complexityAnalysis": [
		{
			"taskId": 1,
			"taskTitle": "Bootstrap Sentinel Python package and CI",
			"complexityScore": 9,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break this into subtasks that cover: extending `pyproject.toml` into a multi-package uv/hatch project for both `specify-cli` and the new `sentinelkit` package, scaffolding the namespace layout (`contracts/`, `context/`, `capsule/`, `prompt/`, `cli/`, `utils/`, `scripts/`, `tests/`) with placeholder modules and a Typer entry point, adding uv metadata (`.tool-versions`, `uv.lock`) plus `sentinelkit/__init__.py`, authoring the Python-only bootstrap script + Makefile updates, replacing `.github/workflows/sentinel-kit.yml` with a Python/uv matrix workflow, and updating README/docs to describe the uv bootstrap and CI badge alongside a smoke test that imports every module.",
			"reasoning": "The repo currently only publishes `specify-cli` in `pyproject.toml:1-23`, so introducing `sentinelkit` requires restructuring the build, dependencies, and uv metadata from scratch. The existing Sentinel workspace is entirely Node-based (`.sentinel/package.json:1-40`) and CI is wired to pnpm/Vitest workflows (`.github/workflows/sentinel-kit.yml:21-157`), so migrating to a uv matrix means redesigning caching, bootstrap, and artifact steps. Documentation and helper scripts still instruct pnpm flows (README.md:96-204, .specify/README.md:12-119, Makefile:1-17), so every contributor-facing surface must switch to Python instructions while preserving Windows/Linux/macOS parity. Implementing namespace scaffolding, Typer entry points, bootstrap commands, CI, and docs simultaneously is broad, cross-cutting work with high coordination cost."
		},
		{
			"taskId": 2,
			"taskTitle": "Implement Typer CLI root and selfcheck wiring",
			"complexityScore": 8,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create subtasks for defining the `sentinelkit/cli/main.py` Typer root with subcommand stubs, building the concurrent `sentinel selfcheck` runner plus shared `--root/--format` options and `utils/errors.py`, adding CLI tests (unit + integration) simulating success/failure of the delegated checks, updating `src/specify_cli/__init__.py` so `specify check` shells out to `uv run sentinel selfcheck` with proper Rich output, and documenting CLI usage in README/spec guides.",
			"reasoning": "No Sentinel CLI exists today; only the Specify CLI is exposed and `specify check` simply tests for installed tools (`src/specify_cli/__init__.py:1164-1205`). Delivering a new Typer app requires designing subcommand routing, concurrency, structured error payloads, and Rich reporting that will later rely on the Python rewrites from Tasks 3-7. Hooking it into `specify check` changes the UX contract for existing users and must coordinate with uv execution patterns established in Task 1. High complexity stems from building new infrastructure, ensuring exit codes bubble correctly, and adding regression tests that stub the various checks while the dependent features are still under development."
		},
		{
			"taskId": 3,
			"taskTitle": "Port contract validation to Python CLI + MCP",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Plan subtasks for re-implementing the contract loader/validator (`sentinelkit/contracts/loader.py`, schema caching, ProducedBy checks) modeled on `.sentinel/scripts/contracts/validator-core.mjs`, exposing a Typer command `sentinel contracts validate` with `--id/--path/--format` options, snapshotting CLI/JSON outputs against fixtures under `tests/contracts/`, adding a reusable API surface for MCP consumers, and wiring regression tests that compare new JSON payloads to the legacy Vitest snapshots.",
			"reasoning": "The existing validator logic lives entirely in Node (`.sentinel/scripts/contracts/validator-core.mjs:1-186`) and depends on Ajv/YAML helpers plus ProducedBy enforcement, with CLI wrappers and Vitest suites (`.sentinel/tests/contracts/*.test.ts`). Rebuilding this in Python requires picking compatible libraries (likely `jsonschema`/`pydantic` + PyYAML), ensuring deterministic ordering, and supporting both CLI and MCP callers with identical JSON schemas. Because downstream workflows (selfcheck, MCP server, slash commands) depend on its outputs, the new implementation must maintain parity with the historical fixtures, making testing and compatibility considerations substantial."
		},
		{
			"taskId": 4,
			"taskTitle": "Build Allowed Context discovery & linting in Python",
			"complexityScore": 7,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Generate subtasks that cover porting `.sentinel/scripts/context/lint.mts` into `sentinelkit/context/` modules (discovery, limits dataclasses, lint CLI), reusing deterministic globbing and forbidden path enforcement, wiring CLI options (`sentinel context lint --capsule/--strict`) with JSON output, updating fixtures/tests under `tests/context/` to mirror the Vitest suite, and integrating shared path utilities for other modules.",
			"reasoning": "The current linter relies on TypeScript + picomatch (`.sentinel/scripts/context/lint.mts:47-365`) and a JSON schema config (`.sentinel/context/limits/context-limits.json:1-40`) with Vitest coverage for good/bad capsules (`.sentinel/tests/context/lint.test.ts:1-38`). Rewriting this in Python entails replicating glob resolution, line-budget warnings, Allowed Context normalization, and CLI ergonomics while ensuring deterministic ordering across platforms. The tool also feeds the capsule generator and future CLI gating, so accuracy and compatibility with the existing fixtures are critical, increasing the implementation and testing burden."
		},
		{
			"taskId": 5,
			"taskTitle": "Implement capsule generator, prompt renderer, and agent prompt sync",
			"complexityScore": 8,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break down the work into subtasks for porting the capsule generator (`sentinelkit/capsule/generator.py`) from `.sentinel/scripts/capsule-create.mjs`, reimplementing the Eta prompt renderer in Python (Jinja2 or equivalent) for router/agent modes, recreating md-surgeon-style snippet syncing for README badges and agent bundles, providing Typer commands (`sentinel capsule generate`, `sentinel prompt render`, prompt sync options), writing golden-file tests under `tests/capsule/` and `tests/prompt/`, and sharing normalized path utilities with the context linter.",
			"reasoning": "The capsule workflow is currently Node-only: generation logic (`.sentinel/scripts/capsule-create.mjs:1-303`), Allowed Context seeding, and md-surgeon-driven snippet syncing (`.sentinel/scripts/md-surgeon.mjs:1-127`) plus Eta prompt rendering referenced throughout the README/spec docs (.specify/README.md:73-119). Replicating this stack in Python requires deterministic markdown rendering, Allowed Context reuse, template token replacement, snippet injection safety checks, and multi-agent sync rules. Tests must compare golden outputs to existing fixtures, and the CLI needs to expose several modes and options, making the task intricate and tightly coupled to other modules."
		},
		{
			"taskId": 6,
			"taskTitle": "Port sentinel regression tests to pytest with CLI wrappers",
			"complexityScore": 7,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Outline subtasks for translating `.sentinel/tests/sentinels/**` Vitest suites to `tests/sentinels/**` in pytest (fixtures, markers, shared data), configuring `pytest.ini` with `pytest-json-report`/`pytest-junitxml`, implementing `sentinelkit/cli/sentinels.py` to invoke `python -m pytest` with marker/filter/report flags, and adding regression tests that assert JSON/JUnit artifacts and CLI exit codes match the prior vitest behavior.",
			"reasoning": "All sentinel regression coverage runs via Vitest today (`.sentinel/tests/sentinels/sentinel_capsule_context.test.ts:1-24`) and CI calls `pnpm --dir=.sentinel vitest ...` (`.github/workflows/sentinel-kit.yml:94-121`), so moving to pytest means rewriting the suites, migrating fixtures, configuring new reporting plugins, and ensuring compatibility with Windows paths. The CLI wrapper has to orchestrate pytest execution, capture JSON/JUnit outputs for CI and selfcheck, and mimic the existing summary schema consumed by agents, so both test translation and command ergonomics add to the workload."
		},
		{
			"taskId": 7,
			"taskTitle": "Implement decision ledger CLI and structured runbook updates",
			"complexityScore": 6,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Create subtasks that cover porting `.sentinel/scripts/decision-log.mjs` into `sentinelkit/cli/decision_log.py` with locking, ProducedBy snippets, and dry-run support, adding runbook maintenance helpers (`sentinelkit/runbook/updater.py`) that update `.sentinel/docs/IMPLEMENTATION.md`, wiring Typer commands for `sentinel decisions append` and `sentinel runbook append`, and writing unit/integration tests for serialization, duplicate detection, and dry-run behavior.",
			"reasoning": "Ledger management currently depends on Node scripts (`.sentinel/scripts/decision-log.mjs:1-189`) and the MCP wrapper (`.sentinel/scripts/mcp/decision-log.mjs:1-116`), with docs referencing pnpm invocations (.specify/README.md:33-68). Re-implementing this in Python requires replicating locking semantics, ID bumping, ProducedBy snippet generation, and Markdown updates while ensuring deterministic outputs for CI diffs. Adding runbook automation introduces another Markdown-editing surface that must interoperate with md-surgeon-style workflows, demanding careful file handling and tests."
		},
		{
			"taskId": 8,
			"taskTitle": "Integrate Sentinel CLI with Specify CLI flows and slash-command gates",
			"complexityScore": 9,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Plan subtasks for enhancing `src/specify_cli/__init__.py` so `specify init --sentinel` copies the Python Sentinel assets (sentinelkit package, .sentinel prompts/agents/templates, workflows) and runs `uv sync` + `sentinel selfcheck`, updating `specify check` and other health commands to run Sentinel gates, refactoring slash-command templates in `templates/commands/*.md` (and supporting bash/ps scripts) so each `/speckit.*` command invokes the new Sentinel subcommands, adding agent bundle sync hooks, and extending tests/mocks to cover these flows.",
			"reasoning": "Today the CLI and slash-command templates only orchestrate shell scripts (`scripts/bash/*.sh`) and pnpm-based Sentinel helpers (templates/commands/plan.md:1-45), with no knowledge of the forthcoming Python CLI. Wiring every entry point (`specify init`, `specify check`, `/speckit.*` commands) to the Sentinel Typer app requires restructuring scaffold logic, file copying, bootstrap steps, and multiple agent bundle sync locations. Because each slash command has both bash and PowerShell automation plus agent context hooks, the integration cuts across templates, scripts, and CLI code, demanding extensive testing and coordination with tasks 1-7."
		},
		{
			"taskId": 9,
			"taskTitle": "Deliver MCP stdio server and smoke tests for sentinel tools",
			"complexityScore": 7,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Break down the task into subtasks for implementing an MCP stdio server under `sentinelkit/cli/mcp/server.py` that exposes contract validation, sentinel runs, and decision log tools via asyncio/jsonrpc, wiring `sentinel mcp smoke` and CLI entry points (`python -m sentinelkit.cli.mcp.server`), updating `.mcp.json` templates and init scaffolding to point to the Python server, and creating pytest smoke tests under `tests/mcp/` that spin up the server, call initialize/tools/list/tools/call, and assert JSON payload parity with the legacy Node responses.",
			"reasoning": "The current MCP servers are discrete Node scripts (`.sentinel/scripts/mcp/contract-validate-server.mjs:1-154`, `sentinel-run.mjs:1-139`, `decision-log.mjs:1-116`) and `.specify/README.md:24-70` instructs pnpm commands plus JSON snippets pointing at those binaries. Replacing them with a single Python stdio server that reuses the new modules from Tasks 3, 6, and 7 requires async process management, JSON-RPC plumbing, tool registration, and smoke coverage to ensure parity. Updating scaffolding (e.g., `.mcp.json` templates) and ensuring CI/selfcheck runs `uv run sentinel mcp smoke` adds coordination overhead across docs, CLI, and tests."
		},
		{
			"taskId": 10,
			"taskTitle": "Remove Node sentinel enclave and harden cross-platform support",
			"complexityScore": 8,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Create subtasks for deleting the legacy `.sentinel` Node workspace (package.json, pnpm lock, Vitest configs, scripts) and updating `.gitignore`, rewriting documentation (README, docs/quickstart.md, .specify/README.md, SUPPORT.md) to reference only uv/sentinel CLI flows, ensuring `specify init --sentinel` scaffolds no Node artifacts and adds Linux hardening notes to `.sentinel/docs/IMPLEMENTATION.md`, adding CI/grep checks that block `pnpm`/`node_modules` references, and documenting the deprecation in DECISIONS.md with migration guidance.",
			"reasoning": "Once the Python tooling lands, the existing Node enclave (`.sentinel/package.json`, `.sentinel/node_modules/**`, Vitest configs, pnpm lockfiles) becomes redundant and must be carefully removed without breaking historical artifacts. Numerous docs and badges still point to the Node workflow (README.md:96-204, .specify/README.md:12-119), so every contributor touchpoint needs updated instructions and Linux/macOS/Windows notes for uv installs. Ensuring `specify init` no longer copies Node assets, updating `.gitignore`, inserting a DECISIONS.md entry, and adding CI safeguards against stray pnpm references requires repo-wide changes and coordination with prior tasks, making this a complex clean-up stage."
		}
	]
}